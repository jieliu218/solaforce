'use strict';

exports.__esModule = true;
exports.getTestList = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var getTestList = exports.getTestList = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(filePath) {
        var fileContent, compiler;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        fileContent = '';
                        _context.prev = 1;
                        _context.next = 4;
                        return readFile(filePath, 'utf8');

                    case 4:
                        fileContent = _context.sent;
                        _context.next = 10;
                        break;

                    case 7:
                        _context.prev = 7;
                        _context.t0 = _context['catch'](1);
                        throw new _runtime.GeneralError(_message2.default.cantFindSpecifiedTestSource, filePath);

                    case 10:
                        compiler = new _esNext2.default();

                        if (compiler.canCompile(fileContent, filePath)) {
                            _context.next = 13;
                            break;
                        }

                        return _context.abrupt('return', []);

                    case 13:
                        return _context.abrupt('return', parseEsNext(fileContent));

                    case 14:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this, [[1, 7]]);
    }));

    return function getTestList(_x) {
        return _ref.apply(this, arguments);
    };
}();

exports.getTestListFromCode = getTestListFromCode;

var _lodash = require('lodash');

var _util = require('util');

var _babelCore = require('babel-core');

var _runtime = require('../../errors/runtime');

var _esNext = require('./formats/es-next');

var _esNext2 = _interopRequireDefault(_esNext);

var _promisify = require('../../utils/promisify');

var _promisify2 = _interopRequireDefault(_promisify);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _message = require('../../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var readFile = (0, _promisify2.default)(_fs2.default.readFile);

var COMPUTED_NAME_TEXT_TMP = '<computed name>(line: %s)';
var METHODS_SPECIFYING_NAME = ['only', 'skip'];

function getRValue(token) {
    return token.declarations[0].init;
}

function getFunctionBody(token) {
    return token.body && token.body.body ? token.body.body : [];
}

function getTagStrValue(exp) {
    //NOTE: we set <computed name> if template literal has at least one computed substring ${...}
    return exp.expressions.length ? (0, _util.format)(COMPUTED_NAME_TEXT_TMP, exp.loc.start.line) : exp.quasis[0].value.raw;
}

function formatFnData(name, value, token) {
    return {
        fnName: name,
        value: value,
        loc: token.loc,
        start: token.start,
        end: token.end
    };
}

function checkExpDefineTargetName(type, apiFn) {
    //NOTE: fixture('fixtureName') or test('testName')
    var isDirectCall = type === 'Identifier';

    //NOTE: fixture.skip('fixtureName'), test.only('testName') etc.
    var isMemberCall = type === 'MemberExpression' && METHODS_SPECIFYING_NAME.indexOf(apiFn) > -1;

    //NOTE: fixture.before().after()('fixtureName'), test.before()`testName`.after() etc.
    var isTailCall = type === 'CallExpression';

    return isDirectCall || isMemberCall || isTailCall;
}

function analyzeMemberExp(token) {
    var exp = token;
    var callStack = [exp];

    while (exp.type !== 'Identifier') {
        if (exp.type === 'CallExpression') exp = exp.callee;else if (exp.type === 'MemberExpression') exp = exp.object;else if (exp.type === 'TaggedTemplateExpression') exp = exp.tag;

        if (exp.type !== 'Identifier') callStack.push(exp);
    }

    if (exp.name !== 'fixture' && exp.name !== 'test') return null;

    var parentExp = callStack.pop();

    if (parentExp.type === 'CallExpression') return formatFnData(exp.name, formatFnArg(parentExp.arguments[0]), token);

    if (parentExp.type === 'TaggedTemplateExpression') return formatFnData(exp.name, getTagStrValue(parentExp.quasi), token);

    if (parentExp.type === 'MemberExpression') {
        while (parentExp) {
            if (parentExp.type === 'CallExpression' && parentExp.callee) {
                var calleeType = parentExp.callee.type;
                var calleeMemberFn = parentExp.callee.property && parentExp.callee.property.name;

                if (checkExpDefineTargetName(calleeType, calleeMemberFn)) return formatFnData(exp.name, formatFnArg(parentExp.arguments[0]), token);
            }

            if (parentExp.type === 'TaggedTemplateExpression' && parentExp.tag) {
                var tagType = parentExp.tag.type;
                var tagMemberFn = parentExp.tag.property && parentExp.tag.property.name;

                if (checkExpDefineTargetName(tagType, tagMemberFn)) return formatFnData(exp.name, getTagStrValue(parentExp.quasi), token);
            }

            parentExp = callStack.pop();
        }
    }

    return null;
}

function formatFnArg(arg) {
    if (arg.type === 'Identifier') return (0, _util.format)(COMPUTED_NAME_TEXT_TMP, arg.loc.start.line);

    if (arg.type === 'TemplateLiteral') return getTagStrValue(arg);

    if (arg.type === 'StringLiteral') return arg.value;

    return null;
}

function getFnCall(token) {
    if (token.callee.name !== 'fixture' && token.callee.name !== 'test') return null;

    return formatFnData(token.callee.name, formatFnArg(token.arguments[0]), token);
}

function getTaggedTemplateExp(token) {
    return formatFnData(token.tag.name, getTagStrValue(token.quasi), token);
}

function analyzeFnCall(token) {
    if (token.type === 'MemberExpression') return analyzeMemberExp(token);

    if (token.type === 'CallExpression') {
        if (token.callee.type === 'MemberExpression' || token.callee.type === 'CallExpression') return analyzeMemberExp(token);

        if (token.callee.type === 'FunctionExpression' || token.callee.type === 'ArrowFunctionExpression') return collectTestCafeCalls(token.callee.body.body);

        return getFnCall(token);
    }

    if (token.type === 'TaggedTemplateExpression') {
        if (token.tag.type === 'MemberExpression') return analyzeMemberExp(token);

        return getTaggedTemplateExp(token);
    }

    return null;
}

function analyzeToken(token) {
    switch (token.type) {
        case 'ExpressionStatement':
            return analyzeToken(token.expression);

        case 'FunctionDeclaration':
        case 'FunctionExpression':
            if (token.async || token.generator) return null;

            return getFunctionBody(token).map(analyzeToken);

        case 'VariableDeclaration':
            return analyzeToken(getRValue(token));

        case 'CallExpression':
        case 'MemberExpression':
        case 'TaggedTemplateExpression':
            return analyzeFnCall(token);
    }

    return null;
}

function collectTestCafeCalls(astBody) {
    var calls = [];

    astBody.forEach(function (token) {
        var callExps = analyzeToken(token);

        if (callExps) calls = calls.concat(callExps);
    });

    return calls;
}

function analyze(astBody) {
    var fixtures = [];
    var testCafeAPICalls = collectTestCafeCalls(astBody);

    testCafeAPICalls.forEach(function (call) {
        if (!call || typeof call.value !== 'string') return;

        if (call.fnName === 'fixture') {
            fixtures.push({
                name: call.value,
                loc: call.loc,
                start: call.start,
                end: call.end,
                tests: []
            });

            return;
        }

        if (!fixtures.length) return;

        fixtures[fixtures.length - 1].tests.push({
            name: call.value,
            loc: call.loc,
            start: call.start,
            end: call.end
        });
    });

    return fixtures;
}

function parseEsNext(code) {
    var compilerOptions = _esNext2.default.getBabelOptions(null, code);

    delete compilerOptions.filename;

    var opts = (0, _lodash.assign)(compilerOptions, { ast: true });
    var ast = (0, _babelCore.transform)(code, opts).ast;

    return analyze(ast.program.body);
}

function getTestListFromCode(code) {
    return parseEsNext(code);
}